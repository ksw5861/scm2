<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.yedam.scm.order.mapper.PayMapper">

  <!-- ==================================== -->
  <!-- 1. 결제 등록 (payment 테이블) -->
  <!-- ==================================== -->
  <insert id="insertPayment" parameterType="PaymentVO">
  <selectKey keyProperty="payId" resultType="string" order="BEFORE">
    SELECT 'PM' || TO_CHAR(SYSDATE, 'YYYYMMDD') || '-' ||
           LPAD(NVL(MAX(SUBSTR(pay_id, 12, 3)), 0) + 1, 3, '0')
    FROM payment
    WHERE pay_id LIKE 'PM' || TO_CHAR(SYSDATE, 'YYYYMMDD') || '-%'
  </selectKey>
  
  INSERT INTO payment (
    pay_id,
    pay_rmk,
    pay_amount,
    vendor_id,
    pay_date,
    pay_type
  ) VALUES (
    #{payId},
    #{payRmk},
    #{payAmount},
    #{vendorId},
    SYSDATE,
    #{payType}
  )
  </insert>


  <!-- ==================================== -->
  <!-- 2. 결제 상세 등록 (payment_detail 테이블) -->
  <!-- 주문건은 total_price, 반품건은 return_price에 각각 저장 -->
  <!-- ==================================== -->
  <insert id="insertPaymentDetail" parameterType="PaymentDetailVO">
    INSERT INTO payment_detail (
      pay_detail_id,
      pay_id,
      order_id,
      total_price,
      return_price
    ) VALUES (
      SEQ_PAY_DETAIL.NEXTVAL,
      #{payId},
      #{orderId},
      #{totalPrice},
      #{returnPrice}
    )
  </insert>

  <!-- ==================================== -->
  <!-- 3. 결제 대기 상태 + 반품 대기 상태 조회 -->
  <!-- COMPLETE(완료) 상태 제외 -->
  <!-- ==================================== -->
<select id="selectPendingOrders" resultType="SalesOrderVO">

 SELECT 
    so.order_id,
    so.order_date,
    so.send_date,
    so.total_price,
    so.pay_status,
    NULL AS return_price,
    'ORDER' AS data_type,
    CASE 
        WHEN COUNT(p.prod_name) > 1 THEN 
            MAX(p.prod_name) || ' 외 ' || (COUNT(p.prod_name)-1) || '건'
        ELSE 
            MAX(p.prod_name)
    END AS prod_name
FROM SALES_ORDER so
JOIN SALES_ORDER_DETAIL sod ON so.order_id = sod.order_id
JOIN PRODUCT p ON sod.prod_id = p.prod_id
WHERE so.pay_status = '대기'
GROUP BY so.order_id, so.order_date, so.send_date, so.total_price, so.pay_status

UNION ALL

SELECT
    r.return_id AS order_id,
    r.return_date AS order_date,
    NULL AS send_date,
    r.return_price AS total_price,
    r.return_status AS pay_status,
    r.return_price,
    'RETURN' AS data_type,
    MAX(p.prod_name) AS prod_name
FROM "RETURN" r
JOIN SALES_ORDER_DETAIL sod ON r.odetail_id = sod.odetail_id
JOIN PRODUCT p ON sod.prod_id = p.prod_id
WHERE TRIM(r.return_status) = '대기'
GROUP BY r.return_id, r.return_date, r.return_price, r.return_status
ORDER BY order_date DESC

</select>





  <!-- ==================================== -->
  <!-- 4. 결제 목록 조회 -->
  <!-- ==================================== -->
  <select id="selectPaymentList" resultType="map">
    WITH SALES_DATA AS (
        SELECT TO_CHAR(ORDER_DATE, 'YYYY-MM') AS MONTH_KEY,
               SUM(TOTAL_PRICE) AS TOTAL_SALES
        FROM SALES_ORDER
        GROUP BY TO_CHAR(ORDER_DATE, 'YYYY-MM')
    ),
    RETURN_DATA AS (
        SELECT TO_CHAR(RETURN_DATE, 'YYYY-MM') AS MONTH_KEY,
               SUM(RETURN_PRICE) AS TOTAL_RETURNS
        FROM RETURN
        GROUP BY TO_CHAR(RETURN_DATE, 'YYYY-MM')
    ),
    PAYMENT_DATA AS (
        SELECT PAY_ID,
               PAY_DATE,
               PAY_RMK,
               VENDOR_ID,
               SUM(PAY_AMOUNT) AS PAY_AMOUNT
        FROM PAYMENT
        GROUP BY PAY_ID, PAY_DATE, PAY_RMK, VENDOR_ID
    )
    SELECT
        PD.PAY_ID,
        TO_CHAR(PD.PAY_DATE, 'YYYY-MM-DD') AS PAY_DATE,
        
        -- 미수금 = 총매출 - 총반품
        NVL(SD.TOTAL_SALES, 0) - NVL(RD.TOTAL_RETURNS, 0) AS OUTSTANDING_AMOUNT,
        
        -- 납부금액
        NVL(PD.PAY_AMOUNT, 0) AS PAY_AMOUNT,
        
        -- 최종잔액 = (총매출 - 총반품) - 납부금액
        (NVL(SD.TOTAL_SALES, 0) - NVL(RD.TOTAL_RETURNS, 0)) - NVL(PD.PAY_AMOUNT, 0) AS FINAL_BALANCE,
        
        -- 여신잔액 = 여신한도(10,000,000) - (총매출 - 총반품)
        (10000000 - (NVL(SD.TOTAL_SALES, 0) - NVL(RD.TOTAL_RETURNS, 0))) AS CREDIT_BALANCE,
        
        PD.PAY_RMK
    FROM PAYMENT_DATA PD
    LEFT JOIN SALES_DATA SD ON TO_CHAR(PD.PAY_DATE, 'YYYY-MM') = SD.MONTH_KEY
    LEFT JOIN RETURN_DATA RD ON TO_CHAR(PD.PAY_DATE, 'YYYY-MM') = RD.MONTH_KEY
    ORDER BY PD.PAY_DATE DESC
  </select>

  <!-- ==================================== -->
  <!-- 5. 결제 상세 조회 -->
  <!-- ==================================== -->
  <select id="selectPaymentDetail" parameterType="string" resultType="PaymentDetailVO">
    SELECT
      pd.pay_detail_id,
      pd.pay_id,
      pd.order_id,
      pd.total_price,
      pd.return_price,
      so.total_price AS order_total_price,
      TO_CHAR(so.order_date, 'YYYY-MM-DD') AS order_date,
      v.vendor_name
    FROM payment_detail pd
    JOIN sales_order so ON pd.order_id = so.order_id
    JOIN vendor v ON so.vendor_id = v.vendor_id
    WHERE pd.pay_id = #{payId}
    ORDER BY pd.order_id
  </select>

  <!-- ==================================== -->
  <!-- 6. 납부 취소 시 삭제 -->
  <!-- ==================================== -->
  <delete id="deletePayment" parameterType="string">
    DELETE FROM payment
    WHERE pay_id = #{payId}
  </delete>

  <delete id="deletePaymentDetail" parameterType="string">
    DELETE FROM payment_detail
    WHERE pay_id = #{payId}
  </delete>

  <!-- ==================================== -->
  <!-- 7. 주문/반품 상태 COMPLETE 업데이트 -->
  <!-- ==================================== -->
  <update id="updateOrderStatusToComplete">
    UPDATE sales_order
    SET pay_status = 'COMPLETE'
    WHERE order_id IN
    <foreach collection="orderId" item="id" open="(" separator="," close=")">
        #{id}
    </foreach>
  </update>


</mapper>
